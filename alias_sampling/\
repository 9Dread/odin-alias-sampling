package odin_alias_sampling

import "core:math/rand"
import "core:math"
import "core:fmt"
import "core:testing"
import "base:runtime"


Alias_Table :: struct {
	prob: []f32,
	alias: []int,
	gen: runtime.Random_Generator,
	alloc: runtime.Allocator
}

deinit_alias_table :: proc(tbl: ^Alias_Table) {
	delete(tbl.prob)
	delete(tbl.alias)
	free(tbl)
}

init_alias_table_f32 :: proc(weights: []f32, copy: bool, gen := context.random_generator, alloc := context.allocator) -> ^Alias_Table {
	//Assumes scaled_probs is normalized properly;
	//if this is not the case, call normalize_vals,
	//or if we want to keep the original values unmodified,
	//allocate a copy of the vals and call normalize_vals
	//on that before passing here.
	normalize_vals_f32(weights)
	n := len(weights)
	small := init_stack()
	large := init_stack()
	defer deinit_stack(small)
	defer deinit_stack(large)

	probs := make([]f32, n)
	alias := make([]int, n)
	for i in 0..<n {
		//initial pass to add
		//stuff to worklists
		prob := weights[i]
		a := init_atom(p=prob, ind=i)
		if prob < 1 {
			//add to small
			push(small, a)
		} else {
			//>=1; add to large
			push(large, a)
		}
	}
	for !stack_empty(small) && !stack_empty(large) {
		s := pop(small)
		l := pop(large)
		probs[s.ind] = s.p
		alias[s.ind] = l.ind

		//update the large probability
		l.p = (l.p + s.p) - 1

		if l.p < 1 {
			push(small, l)
		} else {
			push(large, l)
		}
		//we finalized the small atom;
		//we can free safely
		deinit_atom(s)
	}
	for !stack_empty(large) {
		//if stuff remains stable we should end up in this branch;
		//otherwise we end up in the next one
		l := pop(large)
		probs[l.ind] = 1
		deinit_atom(l)
	}
	for !stack_empty(small) {
		//same
		s := pop(small)
		probs[s.ind] = 1
		deinit_atom(s)
	}
	out := new(Alias_Table)
	out.prob = probs
	out.alias = alias
	out.gen = gen
	out.alloc = alloc
	return out
}

sample_from_tbl :: proc(tbl: ^Alias_Table) -> int {
	//sample an index using the table

	//first, an index of the table
	//[0,n) uniform
	table_ind := rand.int_range(0, len(tbl.prob), gen=Alias_Table.gen)
	
	//[0,1) f32
	biased_coin_prob := rand.float32_range(0, 1)
	prob := tbl.prob[table_ind]
	if biased_coin_prob < prob {
		return table_ind
	} else {
		return tbl.alias[table_ind]
	}
}


normalize_vals_f32 :: proc(vals: []f32) {
	//normalizes vals in place to
	//"scaled probabilities"
	sum: f64 = 0
	for val in vals do sum += f64(val)
	n := len(vals)
	for i in 0..<n {
		vals[i] = vals[i]/f32(sum)*f32(n)
	}
}


main :: proc() {
	vals := make([]f32, 4)
	defer delete(vals)
	vals[0] = 2 //7.1%
	vals[1] = 4 //14.3%
	vals[2] = 8 // 28.5%
	vals[3] = 14 //50%
	//skewed distribution
	tbl := init_alias_table(vals)
	defer deinit_alias_table(tbl)
	zeros := 0
	ones := 0
	twos := 0
	threes := 0
	n := 1000000
	for i in 0..<n {
		val := sample_from_tbl(tbl)
		if val == 0 do zeros += 1
		if val == 1 do ones += 1
		if val == 2 do twos += 1
		if val == 3 do threes += 1
	}
	//print results
	fmt.println("Proportion of 0: ", f32(zeros)/f32(n))
	fmt.println("Proportion of 1: ", f32(ones)/f32(n))
	fmt.println("Proportion of 2: ", f32(twos)/f32(n))
	fmt.println("Proportion of 3: ", f32(threes)/f32(n))	
}

